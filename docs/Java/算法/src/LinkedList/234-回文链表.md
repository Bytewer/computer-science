# 回文链表

https://leetcode.cn/problems/palindrome-linked-list/

## 问题描述

给你一个单链表的头节点 `head` ，请你判断该链表是否为回文链表。如果是，返回 `true` ；否则，返回 `false` 。



## 想法1：快慢指针+反转链表

这个题有一个需要考虑的问题是，最后对比的时候要以上半部分的长度进行while还是下半部分

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public boolean isPalindrome(ListNode head) {
        if (head.next == null) return true;

        ListNode slow = head, fast = head.next;
        while (fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }
        ListNode tmp = slow.next;
        slow.next = null;
        ListNode h = reverseList(tmp);
        slow = head;
        while (h != null) {
            if (slow.val != h.val) return false;
            slow = slow.next;
            h = h.next;
        }
        return true;
    }

    private ListNode reverseList(ListNode head) {
        if (head == null || head.next == null) return head;

        ListNode ans = head;
        head = head.next;
        ans.next = null;

        ListNode pre;
        while (head != null) {
            pre = head;
            head = head.next;
            pre.next = ans;
            ans = pre;
        }
        
        return ans;
    }
}
```



## 想法2：双指针

* 创建一个LinkedList空间 `list`
* 把元素都遍历进去 `while (head != null)`
* 通过LinkedList首尾判断
  * `list.size() > 1 `是排除最后一个元素和没有元素的情况

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public boolean isPalindrome(ListNode head) {
        LinkedList<Integer> list = new LinkedList<>();
        while (head != null) {
            list.addLast(head.val);
            head = head.next;
        }
        while (list.size() > 1) {
            if (list.pollFirst() != list.pollLast()) return false;
        }
        return true;
    }
}
```





## 想法3：递归

这个是我没想到的

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    ListNode front;
    private boolean recursivelyCheck(ListNode cur) {
        if(cur != null) {
            if(!recursivelyCheck(cur.next)) {
                return false;
            }
            if(front.val != cur.val) {
                return false;
            }
            front = front.next;
        }
        
        return true;
    }
    public boolean isPalindrome(ListNode head) {
        front = head;
        return recursivelyCheck(head);
    }
}
```

