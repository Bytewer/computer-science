# 有序链表转换二叉搜索树

https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/

## 问题描述

给定一个单链表的头节点  head ，其中的元素 按升序排序 ，将其转换为高度平衡的二叉搜索树。

本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差不超过 1。



## 第一想法：偷懒写法

借用上一题的函数直接写出答案（将有序链表转成有序数组）

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode sortedListToBST(ListNode head) {
        int[] nums = new int[20000];
        int i = 0;
        while (head != null) {
            nums[i++] = head.val;
            head = head.next;
        }

        return build(nums, 0, i - 1);
    }

    private TreeNode build(int[] nums, int start, int end) {

        if (start > end)
            return null;
        
        int rootIndex = (start + end + 1) / 2;
        
        TreeNode root = new TreeNode(nums[rootIndex]);
        
        root.left = build(nums, start, rootIndex - 1);
        root.right = build(nums, rootIndex + 1, end);

        return root;
    }
}
```

很好，摸鱼很快乐，结果很感人

> 执行结果：通过
> 执行用时：1 ms, 在所有 Java 提交中击败了24.05% 的用户
> 内存消耗：43 MB, 在所有 Java 提交中击败了5.10% 的用户
> 通过测试用例：32 / 32



## 快慢指针

寻找链表的中间点有个小技巧：

快慢指针起初都指向头结点，分别一次走两步和一步，当快指针走到尾节点时，慢指针正好走到链表的中间。断成两个链表，分而治之。

为了断开，我们需要保存慢指针的前一个节点，因为单向链表的结点没有前驱指针。

![](https://pic.leetcode-cn.com/b112a5eba08d0e85771ddaa41c005a7057c8ca05f1e29e0316f0ec15c37c96d5-image.png)

构建代码：

1. 首先我还没有考虑过两个情况 `head == null` 和 `head.next == null`
2. 然后就先写了快慢指针的思想，slow跨一步（next），fast跨两步（next.next）
3. 保存一个前节点（慢指针的上一个位置），注意这里的位置是在赋值完root以后才置为null，不然可能产生stackoverflow
4. 这里的快慢指针判断条件首先要判断自己（快指针）是否为null，不然只判断快指针的下一个位置为导致自己为null无法判断出null；如果只判断自己不判断next，会导致`fast.next.next;`有可能fast.next为null无法算出next.next的位置
5. 最后就是给左右位置很简单了
6. 做完这些要设置这个递归的结束点，也就是当传入的节点为null和next为null的情况，缺一不可！【当然这个点可以提前考虑，我是最后考虑导致踩坑】

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode sortedListToBST(ListNode head) {
        if (head == null) return null;
        if (head.next == null)
            return new TreeNode(head.val);

        ListNode slow = head, fast = head, pre = new ListNode();
        while (fast !=null && fast.next != null) {
            pre = slow;
            slow = slow.next;

            fast = fast.next.next;
        }

        TreeNode root = new TreeNode(slow.val);

        pre.next = null;

        root.left = sortedListToBST(head);

        root.right = sortedListToBST(slow.next);

        return root;
    }

}
```

> 执行结果：通过
>
> 执行用时：0 ms, 在所有 Java 提交中击败了100.00% 的用户
>
> 内存消耗：42.4 MB, 在所有 Java 提交中击败了57.03% 的用户
>
> 通过测试用例：32 / 32