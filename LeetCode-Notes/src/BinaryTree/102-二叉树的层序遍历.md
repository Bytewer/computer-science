# 二叉树的层序遍历
https://leetcode-cn.com/problems/binary-tree-level-order-traversal/

## 问题描述
给你二叉树的根节点 root ，返回其节点值的 层序遍历 。 （即逐层地，从左到右访问所有节点）。

## 第一思路: 队列方式解决
```java
//给你一个二叉树的根节点 root ， 检查它是否轴对称。 
//
// 
//
// 示例 1： 
//
// 
//输入：root = [1,2,2,3,4,4,3]
//输出：true
// 
//
// 示例 2： 
//
// 
//输入：root = [1,2,2,null,3,null,3]
//输出：false
// 
//
// 
//
// 提示： 
//
// 
// 树中节点数目在范围 [1, 1000] 内 
// -100 <= Node.val <= 100 
// 
//
// 
//
// 进阶：你可以运用递归和迭代两种方法解决这个问题吗？ 
// Related Topics 树 深度优先搜索 广度优先搜索 二叉树 👍 1773 👎 0


//leetcode submit region begin(Prohibit modification and deletion)

import java.util.LinkedList;

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 * int val;
 * TreeNode left;
 * TreeNode right;
 * TreeNode() {}
 * TreeNode(int val) { this.val = val; }
 * TreeNode(int val, TreeNode left, TreeNode right) {
 * this.val = val;
 * this.left = left;
 * this.right = right;
 * }
 * }
 */
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> ans = new LinkedList<>();

        // 第一层
        if (root == null)
            return ans;
        else {
            final List<Integer> temp = new LinkedList<>();
            temp.add(root.val);
            ans.add(temp);
        }

        // 如果只有一个节点
        if (root.left == null && root.right == null)
            return ans;

        // 第二层
        LinkedList<TreeNode> curG = new LinkedList<>();
        LinkedList<TreeNode> nextG = new LinkedList<>();

        if (root.left != null)
            curG.add(root.left);
        if (root.right != null)
            curG.add(root.right);

        // 其他层（>2）
        while (curG.size() > 0) {
            List<Integer> elList = new LinkedList<>();

            // 加入上一次的答案, 清除队列元素
            while (curG.size() > 0) {
                final TreeNode node = curG.removeFirst();
                elList.add(node.val);
                // 添加左节点和右节点
                if (el.left != null)
                    nextG.add(el.left);
                if (el.right != null)
                    nextG.add(el.right);
            }

            // 添加队列元素
            ans.add(elList);
            curG.addAll(nextG);
            nextG.clear();
        }

        return ans;
    }
}
```

> 执行结果： 通过  
执行用时：1 ms, 在所有 Java 提交中击败了 79.04% 的用户  
内存消耗：41.2 MB, 在所有 Java 提交中击败了 40.13% 的用户


## 总结: BFS vs DFS
DFS（深度优先搜索）和 BFS（广度优先搜索）
### DFS 与 BFS区别
> DFS遍历
```java
void dfs(TreeNode root) {
    if (root == null) {
        return;
    }
    dfs(root.left);
    dfs(root.right);
}

```

> BFS遍历
```java
void bfs(TreeNode root) {
    Queue<TreeNode> queue = new ArrayDeque<>();
    queue.add(root);
    while (!queue.isEmpty()) {
        TreeNode node = queue.poll(); // Java 的 pop 写作 poll()
        if (node.left != null) {
            queue.add(node.left);
        }
        if (node.right != null) {
            queue.add(node.right);
        }
    }
}

```
只是比较两段代码的话，最直观的感受就是：DFS 遍历的代码比 BFS 简洁太多了！这是因为递归的方式隐含地使用了系统的 栈，我们不需要自己维护一个数据结构。如果只是简单地将二叉树遍历一遍，那么 DFS 显然是更方便的选择。

### BFS 的应用一：层序遍历
https://leetcode-cn.com/problems/binary-tree-level-order-traversal/solution/bfs-de-shi-yong-chang-jing-zong-jie-ceng-xu-bian-l/
### BFS 的应用二：最短路径
https://leetcode-cn.com/problems/binary-tree-level-order-traversal/solution/bfs-de-shi-yong-chang-jing-zong-jie-ceng-xu-bian-l/