# 从中序与后序遍历序列构造二叉树

https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/

## 问题描述

给定两个整数数组 inorder 和 postorder ，其中 inorder 是二叉树的中序遍历， postorder 是同一棵树的后序遍历，请你构造并返回这颗 二叉树 。



## 第一想法：分而治之

1. 排除特殊部分（长度为：0， 1）
2. 建立哈希表（存放中序遍历的位置）
3. 后续遍历的最后一个位置（局部头节点），然后从哈希表中找到中序位置
4. 算出局部头节点左边有几个元素
5. 计算出中序节点的左边范围和后序遍历的左边范围
6. 同理：右边范围
7. ！！难点
   1. 后序遍历的左边范围和右边范围
      1. 左边 【后序遍历的头， 后序遍历的头 + 左边有几个节点】
      2. 右边 【后序遍历的头 + 左边有几个节点，后序遍历的尾 - 1 】
   2. 递归头
      1. 后序遍历头 == 后序遍历尾 【可以通过中序和后序遍历结果都是[2,1]分析得到】

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 * int val;
 * TreeNode left;
 * TreeNode right;
 * TreeNode() {}
 * TreeNode(int val) { this.val = val; }
 * TreeNode(int val, TreeNode left, TreeNode right) {
 * this.val = val;
 * this.left = left;
 * this.right = right;
 * }
 * }
 */
class Solution {
    HashMap<Integer, Integer> map = new HashMap<>();

    public TreeNode buildTree(int[] inorder, int[] postorder) {
        // 判断2种特殊情况
        if (inorder.length == 0) {
            return null;
        }
        if (inorder.length == 1) {
            return new TreeNode(inorder[0]);
        }

        for (int i = 0; i < inorder.length; i++)
            map.put(inorder[i], i);
        return build(inorder, 0, inorder.length, postorder, 0, postorder.length);
    }

    private TreeNode build(int[] inorder, int inStart, int inEnd, int[] postorder, int postStart, int postEnd) {
        
        if (postEnd == postStart) {
            return null;
        }

        // 当前的头结点
        TreeNode cur = new TreeNode(postorder[postEnd - 1]);
        // 当前节点在中序遍历的位置
        int curIndex = map.get(cur.val);

        // 左边元素的个数
        int leftNum = curIndex - inStart;

        cur.left = build(inorder, inStart, curIndex, postorder, postStart, postStart + leftNum);

        cur.right = build(inorder, curIndex + 1, inEnd, postorder, postStart + leftNum, postEnd - 1);

        return cur;
    }
}
```

> 执行结果：
>
> 执行用时：2 ms, 在所有 Java 提交中击败了71.01% 的用户
>
> 内存消耗：40.6 MB, 在所有 Java 提交中击败了77.77% 的用户
>
> 通过测试用例：202 / 202