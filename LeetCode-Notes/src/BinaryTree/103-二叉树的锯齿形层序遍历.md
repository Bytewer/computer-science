# 二叉树的锯齿形层序遍历
https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/
## 问题描述
给你二叉树的根节点 root ，返回其节点值的 锯齿形层序遍历 。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。

## 第一想法：层序遍历+逻辑判断
1. 写出层序遍历的模板
2. 加入当前层是第几次（本算法不用0层，1开始）
3. 在中间部分进行修改
   1. 删除非子节点的最后一个节点（n-i-1）
   2. 判断为偶数层先添加右边再添加左边元素
   3. 判断为奇数层先添加左边再添加右边元素
```java
import java.util.ArrayList;

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 * int val;
 * TreeNode left;
 * TreeNode right;
 * TreeNode() {}
 * TreeNode(int val) { this.val = val; }
 * TreeNode(int val, TreeNode left, TreeNode right) {
 * this.val = val;
 * this.left = left;
 * this.right = right;
 * }
 * }
 */
class Solution {
    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
        List<List<Integer>> ans = new LinkedList<>();

        // 第一层
        if (root == null)
            return ans;
        else {
            final List<Integer> temp = new LinkedList<>();
            temp.add(root.val);
            ans.add(temp);
        }

        // 如果只有一个节点
        if (root.left == null && root.right == null)
            return ans;

        // 第二层
        ArrayList<TreeNode> queue = new ArrayList<>();

        if (root.left != null)
            queue.add(root.left);
        if (root.right != null)
            queue.add(root.right);

        int level = 2;

        // 其他层（>2）
        while (queue.size() > 0) {
            List<Integer> elList = new LinkedList<>();

            int n = queue.size(); // 记忆当前集合的大小，方便下一代加入的时候出现问题

            // 加入上一次的答案, 清除队列元素
            for (int i = 0; i < n; i++) {
                // 偶数行：队列处理；奇数行：栈处理
                final TreeNode node = queue.remove(n - i - 1);
                if (level % 2 == 0) {
                    // 添加右节点和左节点
                    if (node.right != null)
                        queue.add(node.right);
                    if (node.left != null)
                        queue.add(node.left);
                } else {
                    // 添加左节点和右节点
                    if (node.left != null)
                        queue.add(node.left);
                    if (node.right != null)
                        queue.add(node.right);
                }

                elList.add(node.val);

            }

            // 添加队列元素
            ans.add(elList);

            level++;
        }

        return ans;
    }
}
```
> 执行结果： 通过  
执行用时：0 ms, 在所有 Java 提交中击败了 100.00% 的用户  
内存消耗：39.5 MB, 在所有 Java 提交中击败了 46.91% 的用户