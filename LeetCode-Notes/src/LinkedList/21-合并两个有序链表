# 合并两个有序链表

https://leetcode.cn/problems/merge-two-sorted-lists/



## 问题描述

将两个升序链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 



## 想法1：创建节点逐个加入

思路：

1. 这行代码非常的精妙，建议直接背诵`if (list1 == null || list2 == null) return list1 == null ? list2 : list1;`
   1. 这段代码一开始的形态是`if (list1 == null && list2 == null) return list1;`
   2. 在考虑了只有一个有一个没有的情况（例如`list1=[1,2],list2=[]`这类），本来想写成两段if，结果合成一起想就成了现在这段代码，配合三元表达式简直精妙
2. 设置头结点方便进行添加节点
3. 因为哑节点不能动，所以就创建了一个添加操作的节点`dp`
4. 接下来进行常规判断，小的放进dummy节点中
5. 如果有一方空了（说明另外一个链表比较长），就让dp直接指向 ---- >  剩下的节点

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
        if (list1 == null || list2 == null) return list1 == null ? list2 : list1;
        
        ListNode dummy = new ListNode();
        ListNode dp = dummy;
        while (list1 != null && list2 != null) {
            if ( list1.val > list2.val ) {
                dp.next = list2;
                list2 = list2.next;
            } else {
                dp.next = list1;
                list1 = list1.next;
            }
            dp = dp.next;
            while (list1 == null && list2 != null) {
                dp.next = list2;
                break;
            }
            while (list2 == null && list1 != null) {
                dp.next = list1;
                break;
            }
        }

        return dummy.next;
    }
}
```

> 执行结果：通过
>
> 执行用时：0 ms, 在所有 Java 提交中击败了100.00% 的用户
>
> 内存消耗：41 MB, 在所有 Java 提交中击败了33.98% 的用户
>
> 通过测试用例：208 / 208



## 其他想法（后续再补充）：直接不创建，在任一个链表直接添加

