# 从前序与中序遍历序列构造二叉树
https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/

## 问题描述
给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点。

## 第一思路：分而治之
主要思想：每次找到先序的第一个元素，然后再找这个元素在中序的位置，划分左、右  
该方法的唯一缺点在：Arrays.copyOfRange，首先导入了一个大包，然后又每次进行了一次复制，大大增加了时间和空间的开销
```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        return build(preorder, inorder);
    }

    private TreeNode build(int[] preorder, int[] inorder) {
        if (preorder.length == 0) return null;
        // 如果只有一个节点，直接创建出来
        if (preorder.length == 1) return new TreeNode(preorder[0]);

        // 创建先序中第一个节点为头结点
        TreeNode cur = new TreeNode(preorder[0]);
        int curIndex = 0; // 先序节点在中序节点的位置（也可以看作中序左边有多少个元素）

        // 找到先序遍历的那个节点在中序的位置
        for (int i = 0; i < inorder.length; i++) {
            if (cur.val == inorder[i]) {
                curIndex = i;
                break;
            }
        }

        // 分割左区域
        TreeNode left = build(Arrays.copyOfRange(preorder, 1, curIndex + 1), Arrays.copyOfRange(inorder, 0, curIndex));
        // 分割右区域
        TreeNode right = build(Arrays.copyOfRange(preorder, curIndex + 1, inorder.length), Arrays.copyOfRange(inorder, curIndex + 1, inorder.length));

        cur.left = left;
        cur.right = right;

        return cur;
    }
}
```

## 第一次优化：复制改为索引
```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        return build(preorder, 0, preorder.length, inorder, 0, inorder.length);
    }

    private TreeNode build(int[] preorder, int preStart, int preEnd, int[] inorder, int inStart, int inEnd) {
        // preorder 为空，直接返回 null
        if (preStart == preEnd) return null;

        // 创建先序中第一个节点为头结点
        TreeNode cur = new TreeNode(preorder[preStart]);
        int curIndex = 0; // 先序节点在中序节点的位置

        // 找到先序遍历的那个节点在中序的位置
        for (int i = inStart; i < inEnd; i++) {
            if (cur.val == inorder[i]) {
                curIndex = i;
                break;
            }
        }

        int leftNum = curIndex - inStart; // 中序左边有多少个元素

        // 最佳例子
        // pre 3 9 8 27 20 15 6 13 7 1 4
        // in  8 9 27 3 6 15 13 20 1 7 4

        // 分割左区域
        // preStart + 1 每次左边要丢一个元素，就前进一步
        // leftNum + preStart + 1 上一次在左侧开始的位置加上中序遍历后左边剩下的元素+1得到前序左边末尾元素的索引
        // inStart 上一次中序的开端索引
        // curIndex 先序第一个元素在中序的索引位置
        cur.left = build(preorder, preStart + 1, leftNum + preStart + 1, inorder, inStart, curIndex);

        // 分割右区域
        // leftNum + preStart + 1 (可以想象已经分割成两半后，使用右边那一半的范围)从上一次左侧先序的第一个位置加上中序遍历后已知左边元素的个数+1为先序遍历右侧的起始位置
        // preEnd 上一次先序遍历传下来的位置
        // curIndex + 1 先序的第一个位置在中序的位置 + 1 就是中序右侧的第一个位置
        // inEnd 上一次中序传下来的位置
        cur.right = build(preorder, leftNum + preStart + 1, preEnd, inorder, curIndex + 1, inEnd);
        return cur;
    }
}
```

## 第二次优化：中序遍历的结果改为HashMap
```java
// @lc code=start
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {

    HashMap<int, int> map = new HashMap<>();

    public TreeNode buildTree(int[] preorder, int[] inorder) {
        for (int i = 0; i < inorder.length; i++)
            map.put(inorder[i], i);
        return build(preorder, 0, preorder.length, inorder, 0, inorder.length);
    }

    private TreeNode build(int[] preorder, int preStart, int preEnd, int[] inorder, int inStart, int inEnd) {
        // preorder 为空，直接返回 null
        if (preStart == preEnd) return null;

        // 创建先序中第一个节点为头结点
        TreeNode cur = new TreeNode(preorder[preStart]);
        int curIndex = map.get(cur.val);; // 先序节点在中序节点的位置

        int leftNum = curIndex - inStart; // 中序左边有多少个元素

        // 最佳例子
        // pre 3 9 8 27 20 15 6 13 7 1 4
        // in  8 9 27 3 6 15 13 20 1 7 4

        // 分割左区域
        // preStart + 1 每次左边要丢一个元素，就前进一步
        // leftNum + preStart + 1 上一次在左侧开始的位置加上中序遍历后左边剩下的元素+1得到前序左边末尾元素的索引
        // inStart 上一次中序的开端索引
        // curIndex 先序第一个元素在中序的索引位置
        cur.left = build(preorder, preStart + 1, leftNum + preStart + 1, inorder, inStart, curIndex);
        
        // 分割右区域
        // leftNum + preStart + 1 (可以想象已经分割成两半后，使用右边那一半的范围)从上一次左侧先序的第一个位置加上中序遍历后已知左边元素的个数+1为先序遍历右侧的起始位置
        // preEnd 上一次先序遍历传下来的位置
        // curIndex + 1 先序的第一个位置在中序的位置 + 1 就是中序右侧的第一个位置
        // inEnd 上一次中序传下来的位置
        cur.right = build(preorder, leftNum + preStart + 1, preEnd, inorder, curIndex + 1, inEnd);
        return cur;
    }
}
```

> 执行结果： 通过
执行用时：1 ms, 在所有 Java 提交中击败了99.24% 的用户
内存消耗：40.8 MB, 在所有 Java 提交中击败了52.14% 的用户