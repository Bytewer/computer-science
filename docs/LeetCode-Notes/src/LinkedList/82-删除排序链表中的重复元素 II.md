# 删除排序链表中的重复元素 II

https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/

## 问题描述

给定一个已排序的链表的头 `head` ， *删除原始链表中所有重复数字的节点，只留下不同的数字* 。返回 *已排序的链表* 。

## 第一想法：哈希表

我是没想到，我都造了一个aux出来内存还是超过了78%的人

1. 遍历整个链表，把元素放入到哈希表，不重复为true；反之为false
2. 第二次遍历
   1. 遇到true，说明不是重复元素，接到aux上
   2. 遇到false直接跳过

看到本题的评论区有这样一句话：

> 链表的题通常需要注意两点：
>
> 1. 舍得用变量，千万别想着节省变量，否则容易被逻辑绕晕
> 2. head 有可能需要改动时，先增加一个 假head，返回的时候直接取 假head.next，这样就不需要为修改 head 增加一大堆逻辑了

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        HashMap<Integer, Boolean> map = new HashMap<>();
        ListNode slow = head;
        while (slow!= null) {
            if (map.get(slow.val) == null) {
                map.put(slow.val, true);
            } else {
                map.put(slow.val, false);
            }
            slow = slow.next;
        }

        slow = head;
        ListNode aux = new ListNode();
        ListNode p = aux;
        while (slow != null) {
            if (map.get(slow.val)) {
                p.next = new ListNode(slow.val);
                p = p.next;
            }
            slow = slow.next;
        }
        return aux.next;
    }
}
```

> 执行结果：通过
>
> 执行用时：2 ms, 在所有 Java 提交中击败了7.05% 的用户
>
> 内存消耗：40.7 MB, 在所有 Java 提交中击败了78.64% 的用户
>
> 通过测试用例：166 / 166



## 第二想法：一次遍历

一直没想到使用dummyNode，然后看了官网的才意识到dummyNode，自己写了一下，而且一开始写哈希表之前就有这个想法，不过想法是两个节点（cur.next和cur.next.next）两两移动，一直处于逻辑混乱，然后又想了一阵有下面的思路：

1. 空节点直接返回
2. 创建一个dummy
3. cur指向dummy，为什么不指向head？指向head就白申明dummy了（作用只有return dummy.next）
4. 当下一个节点（`next`）不等于下下个节点（`next.next`），直接把当前节点指向到next位置
5. 当相等就创建一个指向下下个节点（`next.next`）的节点（`p`）
   1. `while (p.next != null && p.next.val == cur.next.val)` 是遍历到最后一个和下个节点（`next`）相同的节点
   2. 然后当前节点指向最后一个相同节点的下一个节点（`cur.next = p.next`）
   3. 删除多余节点，让JVM的GC回收下（`p.next = null`）
6. 返回dummyNode的next

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        if (head == null) return head;

        ListNode dummyNode = new ListNode(0, head);

        ListNode cur = dummyNode;
        while (cur.next != null && cur.next.next != null) {
            if (cur.next.val != cur.next.next.val) {
                cur = cur.next;
            } else {
                ListNode p = cur.next.next;
                while (p.next != null && p.next.val == cur.next.val) {
                    p = p.next;
                }
                cur.next = p.next;
                p.next = null;
            }
        }

        return dummyNode.next;
    }
}
```

> 执行结果：通过
>
> 执行用时：0 ms, 在所有 Java 提交中击败了100.00% 的用户
>
> 内存消耗：40.7 MB, 在所有 Java 提交中击败了74.31% 的用户
>
> 通过测试用例：166 / 166

