# 恢复二叉搜索树
https://leetcode-cn.com/problems/recover-binary-search-tree/

## 问题描述
给你二叉搜索树的根节点 root ，该树中的 恰好 两个节点的值被错误地交换。请在不改变其结构的情况下，恢复这棵树 。

## 第一想法: 中序遍历
1. 找到`第一个异常点`（前一个数(pre.val) > 当前数(root.val)）
2. `第一次思考`：找到`第二个异常点`（第一次想的时候是找到最后一次出现当前数(root.val) > 前一个数）
3. `修正思考`：所以采用思路2来解决如何找到`异常点2`的情况，同找到第一个异常点一样（前一个数(pre.val) > 当前数(root.val)），只不过这次的条件是找到了第一个异常点的前提下（anomalNode1 != null）
```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    TreeNode pre = new TreeNode(Integer.MIN_VALUE);

    TreeNode anomalNode1 = null;
    TreeNode anomalNode2 = null;
    
    public void recoverTree(TreeNode root) {
        inorderTraversal(root);
        swap(anomalNode1, anomalNode2);
    }

    private void inorderTraversal(TreeNode root) {
        if (root == null)
            return;
        
…       inorderTraversal(root.left);
        
        if (root.val < pre.val && anomalNode1 == null)
            anomalNode1 = pre;
        if (root.val < pre.val && anomalNode1 != null)
            anomalNode2 = root;
        pre = root;
…       inorderTraversal(root.right);
    }

    private void swap(TreeNode node1, TreeNode node2) {
        int temp = node1.val;
        node1.val = node2.val;
        node2.val = temp;
    }
}
```

## 其他解法
### 解法二：遍历整个二分搜索树，找到两个不有序的位置
注意题目给出的条件，是 二叉搜索树，这就是意味着节点之间是有顺序关系的。
如果我们把整棵树都 遍历 一遍，将遍历的结果保存下来，比如放到一个数组中。
那么这个数组应该是有序的。

既然是有序的那就好办了，我们将这个有序的数组遍历一遍。
如果数组是完全有序的，那么直接返回就可以了。
否则，我们找到顺序不一致的两个下标i和j，将arr[i].val和arr[j].val的值互换一下即可。
![demo2](https://pic.leetcode-cn.com/ceaf09da74f78f235f329dbc588f63da7464590947edb8c0415a4bd9ff493299-1.jpg)

### 解法三：莫里斯遍历优化空间复杂度
https://leetcode-cn.com/problems/recover-binary-search-tree/solution/san-chong-jie-fa-xiang-xi-tu-jie-99-hui-fu-er-cha-/
#### 算法思想
1. 判断cur节点是否为空
2. 如果不为空
   1. 如果cur没有左孩子，cur向右更新，即（cur = cur.right）
   2. 如果cur有左孩子，则从左子树找到最右侧节点pre
      1. 如果pre的右孩子为空，则将右孩子指向cur。pre.right = cur
      2. 如果pre的右孩子为cur，则将其指向为空。pre.right = null。（还原树结构）
3. cur为空时，停止遍历

![](https://img-blog.csdnimg.cn/20200216151818405.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Rhbm1vX3d1aGVu,size_16,color_FFFFFF,t_70#pic_center)
* 将根节点1设置为cur。
* 因为cur（节点1）不为空，且cur（节点1）的左孩子节点2不为空，所以我们找到以节点2为根节点的左子树中最右端的节点5。
* 节点5右孩子为空，此时我们输出cur（节点1）的值，然后将节点5右孩子指向为cur，即节点1。更新cur节点为cur左孩子，即节点2。
* 因为cur（节点2）左孩子不为空，找到其左子树最右端节点4
* 节点4右孩子为空，先输出cur（节点2）的值，再将节点4右孩子指向cur（节点2）,并更新cur（节点2）为其左孩子节点4。
* 这个时候cur（节点4）的左孩子为空，所以访问其右孩子，发现右孩子指向了节点2，所以我们将cur更新为节点2。
* 这个时候我们发现cur又指向了节点2，所以左孩子节点4不为空，我们再次找到左子树中最右端节点4，但是这个时候节点4的右孩子指向了cur，所以我们将其删除，即节点4右孩子指向为空，恢复原来的树结构。并且由于已经访问了左孩子和根节点，所以这个时候我们访问其右孩子节点5。

#### 代码实现
