# 二叉树的最小深度

https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/

## 问题描述

给定一个二叉树，找出其最小深度。

最小深度是从根节点到最近叶子节点的最短路径上的节点数量。

**说明：**叶子节点是指没有子节点的节点。

## 第一想法：后序遍历

思路很简单，性能及其差

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public int minDepth(TreeNode root) {

        if (root == null) return 0;

        int ld = minDepth(root.left);

        int rd = minDepth(root.right);

        if (ld != 0 && rd != 0)
            return Math.min(ld, rd) + 1;;

        return ld == 0 ? rd + 1 : ld + 1;
    }
}
```

> ## Accepted
>
> - 52/52 cases passed (7 ms)
> - Your runtime beats 47.74 % of java submissions
> - Your memory usage beats 5.07 % of java submissions (61.7 MB)



## 第二想法：BFS（广度优先遍历）

第一次想后序遍历得到糟糕的结果一开始想着可能会用哈希表 or 数组进行剪枝，但是想法不对；然后就想到使用层次遍历（BFS的思想）去找空值，如果出现空值就说明出现了最短路径！

1. BFS优化模板（`while(queue.size() > 0)` + `for ( int i = container; i > 0 ; i-- )`）
2. 第二个就是找到空值及时止损跳出循环（也就是发现节点的左右节点都没有值的时候跳出）
3. 维护深度的大小（`depth`）

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {

    public int minDepth(TreeNode root) {

        if (root == null) return 0;

        if ( root.left == null && root.right == null ) return 1;

        LinkedList<TreeNode> queue = new LinkedList<>();

        int depth = 0;

        queue.addLast(root);
        // depth++;
        
        int container = 1;

        boolean specify = true;

        while (queue.size() > 0 && specify) {

            int nextContiner = 0;

            for ( int i = container; i > 0 ; i-- ) {
                TreeNode ele = queue.removeFirst();
                if (ele.left != null) {
                    queue.addLast(ele.left);
                    nextContiner++;
                }

                if (ele.right != null) {
                    queue.addLast(ele.right);
                    nextContiner++;
                }


                if (ele.left == null && ele.right == null) {
                    specify = false;
                    break;
                }
            }
            depth++;

            container = nextContiner;
        }

        return depth;
    }
}
```

> ## Accepted
>
> - 52/52 cases passed (0 ms)
> - Your runtime beats 100 % of java submissions
> - Your memory usage beats 73.04 % of java submissions (60.2 MB)