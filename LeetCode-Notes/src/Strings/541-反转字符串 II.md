# 反转字符串 II

https://leetcode-cn.com/problems/reverse-string-ii/



## 问题描述

给定一个字符串 `s` 和一个整数 `k`，从字符串开头算起，每计数至 `2k` 个字符，就反转这 `2k` 字符中的前 `k` 个字符。

- 如果剩余字符少于 `k` 个，则将剩余字符全部反转。
- 如果剩余字符小于 `2k` 但大于或等于 `k` 个，则反转前 `k` 个字符，其余字符保持原样。



## 第一想法：根据题意进行编写

其中`if (start + 2*k >= s.length() && (s.length() - start) < k)`和 `else if (start + 2*k >= s.length() && (s.length() - start) >= k && (s.length() - start) < 2*k)` 两个判断是拿来判断最后，到末尾的情况只有这两种。

`(s.length() - start)` 这个的意思是剩下的部分。因为步距是1，所以只能最后遇到直接return

缺点：由于没有考虑到步距问题，使用count一个一个递增，增加了算法的时间开销

```java
class Solution {
    public String reverseStr(String s, int k) {
        char[] c = s.toCharArray();
        int count = 0;
        int start = 0;
        for (int i = 0; i < s.length(); i++) {
            count++;
            if (count == 2*k) {
                reverse(c, start, start + k - 1);
                count = 0;
                start = start + 2*k;
            }
            if (start + 2*k >= s.length() && (s.length() - start) < k) {
                reverse(c, start, s.length() - 1);
                return new String(c);
            } else if (start + 2*k >= s.length() && (s.length() - start) >= k && (s.length() - start) < 2*k) {
                reverse(c, start, start + k - 1);
                return new String(c);
            }
        }
        return new String(c);
    }

    private void reverse(char[] ch, int start, int end) {
        for (int i = start, j = end; i <= (start + end) / 2; i++, j-- ) {
            char temp = ch[i];
            ch[i] = ch[j];
            ch[j] = temp;
        }
    }
}

```

> Accepted
> 60/60 cases passed (6 ms) 
> Your runtime beats 6.29 % of java submissions 
> Your memory usage beats 5.07 % of java submissions (41.7 MB)



## 没有想到的：步距和Math.min

1. 把原先算法的`i++`更改为了`i += 2*k`
2. 最后剩下的数判断也变为了`Math.min(i + k , n) - 1`，进而省去了count的计算开销

```java
class Solution {
    public String reverseStr(String s, int k) {
        final int n = s.length();
        char[] c = s.toCharArray();
        for (int i = 0; i < n; i += 2*k) {
            reverse(c, i, Math.min(i + k , n) - 1);
        }
        return new String(c);
    }

    private void reverse(char[] ch, int start, int end) {
        for (int i = start, j = end; i <= (start + end) / 2; i++, j-- ) {
            char temp = ch[i];
            ch[i] = ch[j];
            ch[j] = temp;
        }
    }
}
```

> 执行结果：通过
>
> 执行用时：0 ms, 在所有 Java 提交中击败了100.00% 的用户
>
> 内存消耗：41.3 MB, 在所有 Java 提交中击败了44.97% 的用户
>
> 通过测试用例：60 / 60
