# 2\. 类加载子系统.md
[toc]



## 内存结构概述
![image](images/F2gmY2By3QS-gciYy9TY1PHvg7b882orQ8wLK67Gg9E.png)



## 类加载器子系统的作用
![image](images/80NCg5-HCLDT89aLjSlpcs3KArs7Dr8cmhF3UcnZEcI.png)

* 类加载器子系统负责从文件系统或者网络中加载Class文件，class文件在文件开头有特定的文件标识。
* ClassLoader只负责class文件的加载，至于它是否可以运行，则由ExecutionEngine决定。
* 加载的类信息存放于一块称为方法区的内存空间。除了类的信息外，方法区中还会存放运行时常量池信息，可能还包括字符串字面量和数字常量(这部分常量信息是Class文件中常量池部分的内存映射)



## 类加载过程 -- 3个阶段
![image](images/v7DcvnhSU_REDrJG5SEB1UDaNvwyLvx9mzBWL3yojl8.png)



![image](images/Ml0M_GWWv9Ew32uRb--3_nX3lprdBoTj3EoJKbdpRVs.png)

### 加载过程1：loading
1. 通过一个类的全限定名获取定义此类的二进制字节流
2. 将这个字节流所代表的静态存储结构转换为方法区的运行时数据结构
3. 在内存中生成一个代表这个类的Java.lang.Class对象，作为方法区这个类的各种数据的访问入口



### 加载过程2：Linking
1. 验证

* 目的在于确保cClass文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全。
* 主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。



2. 准备

* 为类变量分配内存并且设置该类变量的默认初始值，即零值。
* 这里不包含用final修饰的static,因为final在编译的时候就会分配了，准备阶段会显式初始化;
* 这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中



3. 解析

* 将常量池内的符号引用转换为直接引用的过程。
* 事实上，解析操作往往会伴随着JVM在执行完初始化之后再执行。
* 符号引用就是一组符号来描述所引用的目标。符号引用的字面量形式明确定义在《java虚拟机规范》的Class文件格式中。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。
* 解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的CONSTANT Class info、 CONSTANT Fieldref info、 CONSTANT Methodref info等 



### 类的加载过程：initialization
* 初始化阶段就是执行类构造器方法<clinit> ()的过程。
* 此方法不需定义，是javac编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来。
* 构造器方法中指令按语句在源文件中出现的顺序执行。
* <clinit>()不同于类的构造器。(关联: 构造器是虚拟机视角下的<init>())
* 若该类具有父类，JVM会 保证子类的<clinit>()执行前，父类的<clinit> ()已经执行完毕。
* 虚拟机必须保证一个类的<clinit>()方法在多线程下被同步加锁。



#### Clinit的使用
当Java代码为这样时

```java
public class ClassInitTest {
    public static int num = 1;

    public static void main(String[] args) {
        System.out.println(ClassInitTest.num);
    }
}
```
clinit会显示字节码为：

> 提示：当int取值**-1\~5**时，JVM采用**iconst**指令将常量压入栈中。

```Plain Text
0 iconst_1
1 putstatic #3 <chapter02/ClassInitTest.num : I>
4 return
```


当Java代码为这样时（加入static 并修改了原先的值）：

```java
public class ClassInitTest {
    public static int num = 1;

    static {
        num = 2;
    }

    public static void main(String[] args) {
        System.out.println(ClassInitTest.num);
    }
}
```
clinit显示字节码：

```Plain Text
0 iconst_1
1 putstatic #3 <chapter02/ClassInitTest.num : I>
4 iconst_2
5 putstatic #3 <chapter02/ClassInitTest.num : I>
8 return
```


当在原先代码中加入number（>5）之后：

```java
public class ClassInitTest {
    public static int num = 1;

    static {
        num = 2;
        number = 20;
    }

    public static int number = 10;

    public static void main(String[] args) {
        System.out.println(ClassInitTest.num);
    }
}
```
clinit显示字节码为：

> 提示：当int取值**-128\~127**时，JVM采用**bipush**指令将常量压入栈中。

```Plain Text
 0 iconst_1
 1 putstatic #3 <chapter02/ClassInitTest.num : I>
 4 iconst_2
 5 putstatic #3 <chapter02/ClassInitTest.num : I>
 8 bipush 20
10 putstatic #5 <chapter02/ClassInitTest.number : I>
13 bipush 10
15 putstatic #5 <chapter02/ClassInitTest.number : I>
18 return
```


#### 非法的前向引用
当调用num时能顺利看到结果，如果在static中再次调用print -- number的结果，则会报非法前向调用的错误

```java
public class ClassInitTest {
    public static int num = 1;

    static {
        num = 2;
        number = 20;
        System.out.println(num);
        System.out.println(number); // 报错：非法前向引用
    }

    public static int number = 10;

    public static void main(String[] args) {
        System.out.println(ClassInitTest.num);
    }
}
```


#### 理解<clinit>()不同于类的构造器
示例：当前代码没有静态变量和静态代码块

```java
public class ClinitTest {

    private int a = 1;

    public static void main(String[] args) {
        int b = 2;
    }
}
```
此时没有clinit（javac编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来）

![image](images/DpmBYyvH6NPQ9HV5vnJv-7b6WCbq8dRFMV1ccOQEzZM.png)
加入static以后

```java
public class ClinitTest {

    private int a = 1;

    public static int c = 3;

    public static void main(String[] args) {
        int b = 2;
    }
}
```
此时就会生成一个clinit

![image](images/jIUbpYnfcGfXm249hCEv9E_nyMygqsrlV1o25JGiNd4.png)

#### 构造器在JVM的字节码
任何一个类声明以后，内部至少存在一个类的构造器：

```java
public class ClinitTest {

    // 任何一个类声明以后，内部至少存在一个类的构造器
    private int a = 1;

    public static int c = 3;

    public static void main(String[] args) {
        int b = 2;
    }
}
```
在  init  中的字节码显示为：

```Plain Text
0 aload_0
1 invokespecial #1 <java/lang/Object.<init> : ()V>
4 aload_0
5 iconst_1
6 putfield #2 <chapter02/ClinitTest.a : I>
9 return
```


#### 具有父类，JVM会 保证子类的<clinit>()执行前，父类的<clinit> ()已经执行完毕
```java
public class ClinitTest1 {

    static class Father {
        public static int A = 1;
        static {
            A = 2;
        }
    }

    static class Son extends Father {
        public static int B = A;
    }

    public static void main(String[] args) {
        // 加载Father, 加载Son
        System.out.println(Son.B); // 2
    }
}
```




#### 虚拟机必须保证一个类只会加载一次（同步加锁）
```java
public class DeadThreadTest {
    public static void main(String[] args) {
        Runnable r = () -> {
            System.out.println(Thread.currentThread().getName() + "开始");
            DeadTread dead = new DeadTread();
            System.out.println(Thread.currentThread().getName() + "结束");
        };

        Thread t1 = new Thread(r, "线程1");
        Thread t2 = new Thread(r, "线程2");

        t1.start();
        t2.start();
    }
}

class DeadTread {
    static {
        if (true) {
            System.out.println(Thread.currentThread().getName() + "初始化当前类");
            while (true) {

            }
        }
    }
}
```
执行结果：

```Plain Text
线程1开始
线程2开始
线程1初始化当前类
```
