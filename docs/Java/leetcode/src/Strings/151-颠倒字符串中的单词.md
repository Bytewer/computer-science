# 颠倒字符串中的单词

https://leetcode-cn.com/problems/reverse-words-in-a-string/

## 问题描述

给你一个字符串 s ，颠倒字符串中 单词 的顺序。

单词 是由非空格字符组成的字符串。s 中使用至少一个空格将字符串中的 单词 分隔开。

返回 单词 顺序颠倒且 单词 之间用单个空格连接的结果字符串。

注意：输入字符串 s中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。

## 第一想法：直接trim() + split()调用API

对，没错，我是一个冷酷无情 API 选手

```java
class Solution {
    public String reverseWords(String s) {
        s = s.trim();
        String[] strs = s.split("\s+");
        int left = 0;
        int right = strs.length - 1;
        while (left < right) {
            String temp = strs[left];
            strs[left] = strs[right];
            strs[right] = temp;
            left++;right--;
        }
        return String.join(" ", strs);
    }
}
```

> **58 / 58** 个通过测试用例
>
> 状态：*通过*
>
> 执行用时: **7 ms**
>
> 内存消耗: **41 MB**



更精简的API

```java
class Solution {
    public String reverseWords(String s) {
        // 除去开头和末尾的空白字符
        s = s.trim();
        // 正则匹配连续的空白字符作为分隔符分割
        List<String> wordList = Arrays.asList(s.split("\\s+"));
        Collections.reverse(wordList);
        return String.join(" ", wordList);
    }
}
```





## 第二想法：两次反转（全局反转+局部反转）

思路：

1. 首先字符串转换为字符数组
2. 进行全局的反转
3. 因为字符串最后结果长度改变了，所以采用`StringBuilder`重建字符串
4. 逐个判断
   1. 如果遇到前面是空格，当前也是空格，直接跳过
   2. 如果遇到空格，则把开始位置移到下一个位置（下一个单词）
   3. 有了以上的维护，就可以进行反转（上一次的start位置 到  当前空格的上一个位置【不是空格】）
   4. 加入到StringBuilder
   5. `if (i == n - 1)`是拿来判断最后一个单词的
5. 最后返回一个字符串

```java
class Solution {
    public String reverseWords(String s) {
        s = s.trim();
        char[] ch = s.toCharArray();
        final int n = s.length();
        // global
        reverse(ch, 0, n - 1);
        // local
        StringBuilder sb = new StringBuilder();
        int start = 0;
        for (int i = 0; i < n; i++) {
            if (ch[i] == 32) {
                if (ch[i-1] == ch[i]) {
                    start = i + 1;
                    continue;
                }
                reverse(ch, start, i - 1);
                sb.append(ch, start, i - start + 1);
                start = i+1;
            } if (i == n - 1) {
                reverse(ch, start, n -1);
                sb.append(ch, start, n - start);
            }
        }
        return sb.toString();
    }

    private void reverse(char[] ch, int left, int right) {
        while (left < right) {
            char temp = ch[left];
            ch[left] = ch[right];
            ch[right] = temp;
            left++;right--;
        }
    }
}
```

> 执行结果：通过
>
> 执行用时：2 ms, 在所有 Java 提交中击败了96.84% 的用户
>
> 内存消耗：41.2 MB, 在所有 Java 提交中击败了44.26% 的用户
>
> 通过测试用例：58 / 58



进一步优化，删除了trim()

```java
public String reverseWords(String s) {
        int start = 0;
        int end = s.length() - 1;
        char[] ch = s.toCharArray();
        // clear left space
        while(ch[start]==' '){
            start++;
        }
        // clear right space
        while(ch[end]==' '){
            end--;
        }
        // global
        reverse(ch, start, end);
        // local
        StringBuilder sb = new StringBuilder();
        for (int i = start; i <= end; i++) {
            if (ch[i] == 32) {
                if (ch[i-1] == ch[i]) {
                    start = i + 1;
                    continue;
                }
                reverse(ch, start, i - 1);
                sb.append(ch, start, i - start + 1);
                start = i+1;
            } if (i == end) {
                reverse(ch, start, end);
                sb.append(ch, start, end - start + 1);
            }
        }
        return sb.toString();
    }

    private void reverse(char[] ch, int left, int right) {
        while (left < right) {
            char temp = ch[left];
            ch[left] = ch[right];
            ch[right] = temp;
            left++;right--;
        }
    }
```

> 执行结果：通过
>
> 执行用时：2 ms, 在所有 Java 提交中击败了96.84% 的用户
>
> 内存消耗：41 MB, 在所有 Java 提交中击败了71.48% 的用户
>
> 通过测试用例：58 / 58



## 另外题解：双端队列、双指针后续补充