# 重排链表

https://leetcode.cn/problems/reorder-list/



## 问题描述

给定一个单链表 L 的头节点 head ，单链表 L 表示为：

L0 → L1 → … → Ln - 1 → Ln

请将其重新排列后变为：

L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …

不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。



## 想法一：快慢指针 + 反转 + 插入

这道题属实有点综合性了，想法一的解法综合了：快慢指针、反转链表、插入链表 三个概念

![image-20220501113136979](images/image-20220501113136979.png)

具体思路：

* 分割是让快慢指针找到中间的位置，并标注中间的下一个位置，以此分割两个链表
* 下半部分反转直接参考LC.206
* 最后在下半部分不为null的条件下，挨个插入到上半部分（此时下半部分已经原地反转了）

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public void reorderList(ListNode head) {
        // 分割
        ListNode mid = head, tail = head.next;
        while (tail != null && tail.next != null) {
            mid = mid.next;
            tail = tail.next.next;
        }
        ListNode tmp = mid.next;
        mid.next = null;
        // 下半部分原地反转
        ListNode h = reverseList(tmp);
        // 上半部分插入下半部分
        ListNode p = head;
        while (h != null ) {
            ListNode tmpH = h;
            h = h.next;
            tmpH.next = p.next;
            p.next = tmpH;
            p = tmpH.next;
        }
    }

    private ListNode reverseList(ListNode head) {
        if (head == null || head.next == null) return head;

        ListNode ans = head;
        head = head.next;
        ans.next = null;

        ListNode pre;
        while (head != null) {
            pre = head;
            head = head.next;
            pre.next = ans;
            ans = pre;
        }
        
        return ans;
    }
}
```

> 执行结果：通过
>
> 执行用时：1 ms, 在所有 Java 提交中击败了99.99% 的用户
>
> 内存消耗：44.2 MB, 在所有 Java 提交中击败了24.05% 的用户
>
> 通过测试用例：12 / 12

> 注：在此之前我还想过循环链表实现，但是过于复杂直接放弃，以后有时间再写这个题解了。