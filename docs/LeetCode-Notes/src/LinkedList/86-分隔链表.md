# 分隔链表

https://leetcode.cn/problems/partition-list/

## 问题描述

给你一个链表的头节点 head 和一个特定值 x ，请你对链表进行分隔，使得所有 小于 x 的节点都出现在 大于或等于 x 的节点之前。

你应当 保留 两个分区中每个节点的初始相对位置。

![](https://assets.leetcode.com/uploads/2021/01/04/partition.jpg)



## 想法一：哑节点

做了这么多题的总结是，凡是第一个节点要判断都要使用到哑节点

创建哑节点（`dummy`），慢指针（`slow`），快指针（`fast`），快指针的上一个节点（`fastPre`）

* `if (fast.val < x && fastPre != slow) `题目条件：I. 小于的要放前面 II. 如果慢指针在快指针上一个的位置，那么说明出现了连续<x的节点，解决方案就是移动slow（`else if (fast.val < x && fastPre == slow) `），不然`fast.val < x && fastPre != slow`内的代码段没有解决连续<x的情况。
* 其他情况只移动fast和fastpre就可以

这段代码一开始没有考虑到`else if (fast.val < x && fastPre == slow) `，提交了4次都没有通过，直到考虑到`[1,1,2] 3`的问题就迎刃而解

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode partition(ListNode head, int x) {
        ListNode dummy = new ListNode(0, head);
        ListNode slow = dummy;
        ListNode fast = head, fastPre = dummy;
        while (fast != null) {
            if (fast.val < x && fastPre != slow) {
                ListNode temp = fast;
                fast = fast.next;
                fastPre.next = fast;
                temp.next = slow.next;
                slow.next = temp;
                slow = slow.next;
                continue;
            } else if (fast.val < x && fastPre == slow) {
                slow = slow.next;
            }
            fastPre = fast;
            fast = fast.next;
        }
        return dummy.next;
    }
}
```

> 执行结果：通过
>
> 执行用时：0 ms, 在所有 Java 提交中击败了100.00% 的用户
>
> 内存消耗：40.6 MB, 在所有 Java 提交中击败了80.42% 的用户
>
> 通过测试用例：168 / 168