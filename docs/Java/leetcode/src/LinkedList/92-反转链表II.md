# 反转链表II

https://leetcode-cn.com/problems/reverse-linked-list-ii/



## 问题描述

给你单链表的头指针 head 和两个整数 left 和 right ，其中 left <= right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。 

![](https://assets.leetcode.com/uploads/2021/02/19/rev2ex2.jpg)



## 第一想法：直接迭代

由于脑子不好使，用了两次while循环

1. 首先判断两个特殊情况
2. 一开始我没用哑节点（`dummy`）的，是因为后面写着写着考虑到如果要反转的列表包含第一个元素，就有点难反转，所以加入了哑节点
3. 第一个while主要是找到传入参数（`left`）所在的节点的前一个位置（`left - 1`）
4. 然后标记这个（`leftNode`）为第一个while找到的节点
5. 后续跳出这个节点，使（cur，pre）都在left和right里面；并标记（`rightNode`）为最后一个元素，即反转前的一个元素就是最后一个元素
6. 第二个while很好理解，就是206题反转列表的题解写法
7. 标记为left左边的那个节点（`leftNode`）指向最后一个元素（以上述图示【1,2,3，4,5转1,4,3,2,5】为例的话就是`4`所在的位置）
8. 标记为最后一个节点的位置（`rightNode`）指向最后一个位置（cur的后面，在图示的位置就是`5`所在的位置）

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode reverseBetween(ListNode head, int left, int right) {
        if (head == null || head.next == null) return head;

        ListNode dummy = new ListNode(0, head);

        int count = 0;
        ListNode cur = dummy;
        while (count != left - 1) {
            count++;
            cur = cur.next;
        }
        ListNode leftNode = cur; // 被调换子串头结点的上一个元素

        count++;
        cur = cur.next;
        ListNode pre = cur.next;
        ListNode rightNode= cur; // 被调换子串的最后一个元素
        
        while (count != right) {
            ListNode temp = pre;
            pre = pre.next;
            temp.next = cur;
            cur = temp;
            count++;
        }
        rightNode.next = pre;
        leftNode.next = cur;

        return dummy.next;
    }
}
```

> **44 / 44** 个通过测试用例
>
> 状态：*通过*
>
> 执行用时: **0 ms**
>
> 内存消耗: **39.2 MB**