# 个人定制八股文

整理自吴师兄的：1000道Java 程序员必备面试题-V1版



## Java基础

### ArrayList和LinkedList有什么区别？

1. ArrayList和LinkedList的差别主要来⾃于Array和LinkedList数据结构的不同。ArrayList是基于数组实现的，LinkedList是基于双链表实现的。另外LinkedList类不仅是List接⼝的实现类，可以根据索引来随机访问集合中的元素，除此之外，LinkedList还实现了Deque接⼝，Deque接⼝是Queue接⼝的⼦接⼝，它代表⼀个双向队列，因此LinkedList可以作为双向队列，栈（可以参⻅Deque提供的接⼝⽅法）和List集合使⽤，功能强⼤。
2. 因为Array是基于索引(index)的数据结构，它使⽤索引在数组中搜索和读取数据是很快的，可以直接返回数组中index位置的元素，因此在随机访问集合元素上有较好的性能。Array获取数据的时间复杂度是O(1),但是要插⼊、删除数据却是开销很⼤的，因为这需要移动数组中插⼊位置之后的的所有元素。
3. 相对于ArrayList，LinkedList的随机访问集合元素时性能较差，因为需要在双向列表中找到要index的位置，再返回；但在插⼊，删除操作是更快的。因为LinkedList不像ArrayList⼀样，不需要改变数组的⼤⼩，也不需要在数组装满的时候要将所有的数据重新装⼊⼀个新的数组，这是ArrayList最坏的⼀种情况，时间复杂度是O(n)，⽽LinkedList中插⼊或删除的时间复杂度仅为O(1)。ArrayList在插⼊数据时还需要更新索引（除了插⼊数组的尾部）。
4. LinkedList需要更多的内存，因为ArrayList的每个索引的位置是实际的数据，⽽LinkedList中的每个节点中存储的是实际的数据和前后节点的位置。



### Java 8的接⼝新增了哪些特性？

增加了default⽅法和static⽅法，这2种⽅法可以有⽅法体



### 抽象类和接⼝（Java7）的区别

1. 抽象类可以提供成员⽅法的实现细节，⽽接⼝中只能存在public abstract ⽅法；
2. 抽象类中的成员变量可以是各种类型的，⽽接⼝中的成员变量只能是public static final 类型的；
3. 接⼝中不能含有静态代码块以及静态⽅法，⽽抽象类可以有静态代码块和静态⽅法；
4. ⼀个类只能继承⼀个抽象类，⽽⼀个类却可以实现多个接⼝。



### HashSet 如何检查重复

​	当你把对象加⼊HashSet时，HashSet会先计算对象的hashcode值来判断对象加⼊的位置，同时也会与其他已经加⼊的对象的hashcode值作⽐较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同hashcode值的对象，这时会调⽤equals()⽅法来检查hashcode相等的对象是否真的相同。如果两者相同，HashSet就不会让其加⼊操作成功。如果不同的话，就会重新散列到其他位置。（摘⾃我的Java启蒙书《Headfirstjava》第⼆版）。这样我们就⼤⼤减少了equals的次数，相应就⼤⼤提⾼了执⾏速度。



#### hashCode()与equals()：

如果两个对象相等，则hashcode⼀定也是相同的
两个对象相等，对两个对象分别调⽤equals⽅法都返回true
两个对象有相同的hashcode值，它们也不⼀定是相等的



### 构造⽅法有哪些特性？

名字与类名相同；
没有返回值，但不能⽤void声明构造函数；
⽣成类的对象时⾃动执⾏，⽆需调⽤。



### static

1、静态只能访问静态。
2、⾮静态既可以访问⾮静态的，也可以访问静态的。



1、被static修饰的变量或者⽅法是独⽴于该类的任何对象，也就是说，这些变量和⽅法不属于任何⼀个实例对象，⽽是被类的实例对象所共享。怎么理解“被类的实例对象所共享”这句话呢？就是说，⼀个类的静态成员，它是属于⼤伙的【⼤伙指的是这个类的多个对象实例，我们都知道⼀个类可以创建多个实例！】，所有的类对象共享的，不像成员变量是⾃个的【⾃个指的是这个类的单个实例对象】…我觉得我已经讲的很通俗了，你明⽩了咩？

2、在该类被第⼀次加载的时候，就会去加载被static修饰的部分，⽽且只在类第⼀次使⽤时加载并进⾏初始化，注意这是第⼀次⽤就要初始化，后⾯根据需要是可以再次赋值的。

3、static变量值在类加载的时候分配空间，以后创建类对象的时候不会重新分配。赋值的话，是可以任意赋值的！

4、被static修饰的变量或者⽅法是优先于对象存在的，也就是说当⼀个类加载完毕之后，即便没有创建对象，也可以去访问。



#### 存在的意义？

static的主要意义是在于创建独⽴于具体对象的域变量或者⽅法。以致于即使没有创建对象，也能使⽤属性和调⽤⽅法！

static关键字还有⼀个⽐较关键的作⽤就是⽤来形成静态代码块以优化程序性能。static块可以置于类中的任何地⽅，类中可以有多个static块。在类初次被加载的时候，会按照static块的顺序来执⾏每个static块，并且只会执⾏⼀次。

为什么说static块可以⽤来优化程序性能，是因为它的特性:只会在类加载的时候执⾏⼀次。因此，很多时候会将⼀些只需要进⾏⼀次的初始化操作都放在static代码块中进⾏。



### this与super的区别

* super:它引⽤当前对象的直接⽗类中的成员（⽤来访问直接⽗类中被隐藏的⽗类中成员数据或函数，基类与派⽣类中有相同成员定义时如：super.变量名super.成员函数据名（实参）
* this：它代表当前对象名（在程序中易产⽣⼆义性之处，应使⽤this来指明当前对象；如果函数的形参与类中的成员数据同名，这时需⽤this来指明成员变量名）
* super()和this()类似,区别是，super()在⼦类中调⽤⽗类的构造⽅法，this()在本类内调⽤本类的其它构造⽅法。
* super()和this()均需放在构造⽅法内第⼀⾏。
* 尽管可以⽤this调⽤⼀个构造器，但却不能调⽤两个。
* this和super不能同时出现在⼀个构造函数⾥⾯，因为this必然会调⽤其它的构造函数，其它的构造函数必然也会有super语句的存在，所以在同⼀个构造函数⾥⾯有相同的语句，就失去了语句的意义，编译器也不会通过。
* this()和super()都指的是对象，所以，均不可以在static环境中使⽤。包括：static变量,static⽅法，static语句块。
* 从本质上讲，this是⼀个指向本对象的指针,然⽽super是⼀个Java关键字。



super（参数）：调⽤⽗类中的某⼀个构造函数（应该为构造函数中的第⼀条语句）。
this（参数）：调⽤本类中另⼀种形式的构造函数（应该为构造函数中的第⼀条语句）。



### char型变量中能否能不能存储⼀个中⽂汉字，为什么？

char可以存储⼀个中⽂汉字，因为Java中使⽤的编码是Unicode(不选择任何特定的编码，直接使⽤字符在字符集中的编号，这是统⼀的唯⼀⽅法），⼀个char类型占2个字节（16⽐特），所以放⼀个中⽂是没问题的。



### 是否可以继承String类？

String类是final类，不可以被继承。

补充：继承String本身就是⼀个错误的⾏为，对String类型最好的重⽤⽅式是关联关系（Has-A）和依赖关系（Use-A）⽽不是继承关系（Is-A）。



### 谈谈你对多态的理解？

多态就是指程序中定义的引⽤变量所指向的具体类型和通过该引⽤变量发出的⽅法调⽤在编程时并不确定，⽽是在程序运⾏期间才确定，即⼀个引⽤变量到底会指向哪个类的实例对象，该引⽤变量发出的⽅法调⽤到底是哪个类中实现的⽅法，必须在程序运⾏期间才能决定。因为在程序运⾏时才确定具体的类，这样，不⽤修改源代码，就可以让引⽤变量绑定到各种不同的对象上，从⽽导致该引⽤调⽤的具体⽅法随之改变，即不修改程序代码就可以改变程序运⾏时所绑定的具体代码，让程序可以选择多个运⾏状态，这就是多态性。

Java中的多态靠的是⽗类或接⼝定义的引⽤变量可以指向⼦类或具体实现类的实例对象，⽽程序调⽤的⽅法在运⾏期才动态绑定，就是引⽤变量所指向的具体实例对象的⽅法，也就是内存⾥正在运⾏的那个对象的⽅法，⽽不是引⽤变量的类型中定义的⽅法。



### 构造器（constructor）是否可被重写（override）？

构造器不能被继承，因此不能被重写，但可以被重载



### new⼀个对象的过程和clone⼀个对象的区别？

new ： 分配内存 --> 构造函数 --> 返回引用地址

clone：分配内存 --> 填充  --> 返回引用地址



### Java 中操作字符串都有哪些类？它们之间有什么区别？

操作字符串的类有：**String、StringBuffer、StringBuilder**。

String和StringBuffer、StringBuilder的区别在于String声明的是不可变的对象，每次操作都会⽣成新的String对象，再将指针指向新的String对象，⽽StringBuffer、StringBuilder可以在原有对象的基础上进⾏操作，所以在经常改变字符串内容的情况下最好不要使⽤String。

StringBuffer和StringBuilder最⼤的区别在于，StringBuffer是线程安全的，⽽StringBuilder是⾮线程安全的，但StringBuilder的性能却⾼于StringBuffer，所以在单线程环境下推荐使⽤StringBuilder，多线程环境下推荐使⽤StringBuffer
