# 平衡二叉树

https://leetcode-cn.com/problems/balanced-binary-tree/

## 问题描述

给定一个二叉树，判断它是否是高度平衡的二叉树。

本题中，一棵高度平衡二叉树定义为：

    一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。



## 第一想法：后序遍历+判断

递归返回值：

* 当节点root 左 / 右子树的高度差 <2 ：则返回以节点root为根节点的子树的最大高度，即节点 root 的左右子树中最大高度加 1 （ max(left, right) + 1 ）；
* 当节点root 左 / 右子树的高度差 ≥2 ：则返回 −1 ，代表 此子树不是平衡树 。

递归终止条件：

* 当越过叶子节点时，返回高度 0 ；
* 当左（右）子树高度 left== -1 时，代表此子树的 左（右）子树 不是平衡树，因此直接返回 −1；

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public boolean isBalanced(TreeNode root) {
        if (root == null) {
            return true;
        }
        return treeHeight(root) != -1;
    }

    private int treeHeight(TreeNode root) {
        if (root == null) return 0;

        if (root.left == null && root.right == null)
            return 1;

        int l = treeHeight(root.left);

        int r = treeHeight(root.right);

        if (l == -1 || r == -1)
            return -1;

        if (l == 0)
            return r > 1 ? -1 : r + 1;
        
        if (r == 0)
            return l > 1 ? -1 : l + 1;

        // l != 0 && r != 0
        return Math.abs(l - r) > 1 ? -1 : Math.max(l, r) + 1;
    }
}
```

> ## Accepted
>
> - 228/228 cases passed (0 ms)
> - Your runtime beats 100 % of java submissions
> - Your memory usage beats 50.88 % of java submissions (40.9 MB)



## 一年前写的想法，也不知道怎么想的，很精简

自底向上递归的做法类似于后序遍历，对于当前遍历到的节点，先递归地判断其左右子树是否平衡，再判断以当前节点为根的子树是否平衡。如果一棵子树是平衡的，则返回其高度（高度一定是非负整数），否则返回 −1-1−1。如果存在一棵子树不平衡，则整个二叉树一定不平衡。

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public int height(TreeNode root) {
        if (root == null) {
            return 0;
        }
        int lh = height(root.left);
        int rh = height(root.right);
        if (lh == -1 || rh == -1 || Math.abs(lh - rh) > 1)
            return -1;
        else {
            return Math.max(lh, rh) + 1;
        }
    }

    public boolean isBalanced(TreeNode root) {
        return height(root) >= 0;
    }
}

```

> ### 提交记录
>
> **228 / 228** 个通过测试用例
>
> 状态：*通过*
>
> 执行用时: **1 ms**
>
> 内存消耗: **38.5 MB**